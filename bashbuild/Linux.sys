[[ -z "$CXX" ]] && export CXX="g++"
[[ -z "$CC"  ]] && export CC="gcc" 
[[ -z "$GPROF" ]] && export GPROF="gprof"

export   GCCVER="$($CC --version 2>/dev/null | grep gcc   | head -1 | sed 's/^.* //g')"
export CLANGVER="$($CC --version 2>/dev/null | grep clang | head -1 | sed 's/^.* //g')"

export GCCCOLORIZED=""
[[ -n "${CLANGVER}"     ]]  && GCCCOLORIZED="-Xclang -fcolor-diagnostics"
[[ "${GCCVER}" > "4.8"  ]]  && GCCCOLORIZED="-fdiagnostics-color=always"

export LINKOPTS="${LINKOPTS} ${GCCCOLORIZED}"
export   CFLAGS="${CFLAGS} ${GCCCOLORIZED} -fcommon -fwrapv -fno-strict-aliasing -Wno-write-strings -O2 -ffast-math -fomit-frame-pointer"
export CXXFLAGS="${CXXFLAGS} ${GCCCOLORIZED} -fcommon -fwrapv -fno-strict-aliasing -Wno-write-strings -O2 -ffast-math -fomit-frame-pointer"

#export LDFLAGS=""
#export SYSLIBS=""
#export GCCSTATIC=""

export LINUX="Linux"
export MACHINE="$( uname -m )"
export OMACHINE="$( uname -m )"

export AROPTS="crD"
[[ -z "$AR"     ]] && export AR="$( which ar )"
[[ -z "$RANLIB" ]] && export RANLIB="$( which ranlib )"

if [[ -z "${GCCVER}${CLAGVER}" ]]; then
   echo "Could not detect/find C/C++ compiler, I know how to deal with GCC or CLANG" 1>&2
   exit 4
fi

if [[ -z "${AR}" ]]; then
   echo "Could not detect/find AR archiver which is needed for libraries" 1>&2
   exit 4
fi

if [[ -z "${RANLIB}" ]]; then
   echo "Could not detect/find RANLIB which is needed for libraries" 1>&2
   exit 4
fi


export PREFIX="/usr/local/bin"
export PREFIXLIB="/usr/local/share/"

export CLICMD=""
export GUIAPP=""

export HASHOPTS="-b --tag"


if [[ -f /etc/os-release ]]; then
   eval $(sed -e 's/^/export OSREL_/g' /etc/os-release  )
fi

# Only used on Windows
function windres() {
true 
}


# Note by @TorZidan: 
# Here is a typical content of the generated debian package:
# dpkg --info pkg/LisaEm-1.2.7-RC4-2022.04.01-ubuntu-24.04-amd64.deb 
#  new Debian package, version 2.0.
#  size 3871750 bytes: control archive=357 bytes.
#      325 bytes,     8 lines      control
#  Package: LisaEm
#  Version: 1.2.7-RC4-2022.04.01
#  Architecture: amd64
#  Maintainer: Ray Arachelian <jeremysalwen>
#  Depends: gtk3, gdk-pixbuf2, libpangocairo, libgtk, libcario, libpangoft2, libpango1, libtiff, libglib
#  Installed-Size: 10848
#  Homepage: https://lisaem.sunder.net
#  Description: The first fully functional Lisa Emulatorâ„¢
#
# There are numberous problems here, which I (@TorZidan) have decided to leave as is:
# - The package name "LisaEm" should be all-lowercase. But renaming it to "lisaem" may break existing installations.
#   It is still doable, by adding 2 more fields:  Replaces: LisaEm (<< 1.2.7~rc4) , Breaks: LisaEm (<< 1.2.7~rc4)
# - The version "1.2.7-RC4-2022.04.01" should be e.g. "1.2.7~rc4-2022.04.01", so that
#   the release version "1.2.7-2022.04.01" will be newer (currently it is older) than this.
# - The "Depends" field has incorrect, outdated values.
# - The package files are being installed in "/usr/local/bin" and "/usr/local/share/", which is not standard, see them with "dpkg -c <filename>
function makedebpkgcontrol() {
size=$(du -sk "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}" | cut -f1)

CONTROL="$1/control"
machine="$(echo $MACHINE | sed -e 's/x86_64/amd64/g' )" # DEBs prefer amd64 in architecture.

# The debian package version must start with a digit
# and the allowed characters are: digits, letters, .+-~:
DEBVERSION="${VER}"
if [[ -z "$VER" ]] || [[ "$VER" == "undefined" ]] || [[ "$VER" == "continuous-"* ]]; then
   DEBVERSION="0-${VER}"
fi

cat >"$CONTROL" <<ENDDEBCONTROLEND || exit $?
Package: ${SOFTWARE}
Version: ${DEBVERSION}
Architecture: ${machine}
Maintainer: ${AUTHOR} <${AUTHEMAIL}>
Depends: $DEBDEPENDS
Installed-Size: $size
Homepage: ${URL}
Description: ${DESCRIPTION}
ENDDEBCONTROLEND

chmod 600 "$CONTROL" || exit $?
}

# create file system as intended under pkg/build/tmp/root before calling this.
function LinuxDebianPackage() {
  if [[ -z "$( which dpkg-deb 2>/dev/null )" ]]; then return 0; fi

  pushd "${XTLD}/pkg" >/dev/null 2>/dev/null || exit $? 
  mkdir -pm755 build/tmp
  cd build/tmp || exit $?

  # The generated Debian package file name. It will be further renamed when building it on Github Actions.
  export DEBNAME="${XTLD}/pkg/${SOFTWARE}_amd64.deb"

  echo "  + $DEBNAME" 1>&2

  DEBSTAGE="${XTLD}/pkg/build/tmp/deb/${SOFTWARE}"

  mkdir -pm755 "$DEBSTAGE/DEBIAN"

  # copy artifacts to debian pkg structure
  if [[ ! -d "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/" ]]; then
     echo "PREFIX ${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/ is missing" 1>&2
     exit 1
  fi

  if [[ ! -d "${DEBSTAGE}" ]]; then
     echo "DEBSTAGE ${DEBSTAGE} is missing" 1>&2
     exit 1
  fi

  #echo "cloning from ${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/ $(du -sh ${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/)" 1>&2
  (cd "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/" && tar cpf - .) | (cd "${DEBSTAGE}" && tar xpf -)
  #echo "to           $DEBSTAGE $(du -sh $DEBSTAGE)" 1>&2

  makedebpkgcontrol "$DEBSTAGE/DEBIAN"

  # build the package
  cd "${XTLD}/pkg/build/tmp/deb" || exit $?

  dpkg-deb --build ${SOFTWARE} "$DEBNAME" 2>&1 >"${DEBNAME}.log" || exit $?

  # create hashes
  if [[ -f "$DEBNAME" ]]; then
     cd "$XTLD/pkg"
     [[ -n "$MD5SUM" ]]    && $MD5SUM  "$DEBNAME" >"${DEBNAME}.md5"
     [[ -n "$SHA1SUM" ]]   && $SHA1SUM "$DEBNAME" >"${DEBNAME}.sha1"
     [[ -n "$SHA256SUM" ]] && $SHA1SUM "$DEBNAME" >"${DEBNAME}.sha256"
  fi

  # cleanup
  rm -rf "${XTLD}/pkg/tmp/deb"
  popd >/dev/null 2>/dev/null
}


function makerpmspec() {

specname="$1"
tarname="$2"

for i in $(echo $RPMDEPENDS | sed -e 's/,//g' ); do
  BUILDREQUIRES="${BUILDREQUIRES}$(printf 'BuildRequires: %s\n' $i )"
done

cat >"$specname" <<ENDRPMSPEC
%define name            ${SOFTWARE}
%define release         ${RELEASEDATE}
%define version         ${VERSION}
%define buildroot       /var/tmp/%{name}-buildroot
%define source          ${tarname}

BuildRoot:              %{buildroot}
Summary:                ${DESCRIPTION}
License:                $LICENSESHORT
Name:                   %{name}
Version:                %{version}
Release:                %{release}
Source:                 %{source}

$BUILDREQUIRES

%description
${DESCRIPTION}

%pre
if [[ "\$(uname -m)" != "$MACHINE" ]]; then
   echo "This package was compiled for $MACHINE systems, your system is \$(uname -m)" 1>&2
   exit 1
fi

%prep

%setup -q build

%install
rm -rf \$RPM_BUILD_ROOT
mkdir \$RPM_BUILD_ROOT
cp -r * \$RPM_BUILD_ROOT

%clean
rm -rf \$RPM_BUILD_ROOT

%files
ENDRPMSPEC

(pushd "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}" 2>/dev/null >/dev/null
 find . -type f -print  | cut -c2-
 popd >/dev/null 2>/dev/null
) >>"$specname"

}


function LinuxRPMPackage() {
  [[ -z "$( which rpmdev-setuptree 2>/dev/null )" ]] && return 0

  pushd . >/dev/null 2>/dev/null

  if [[ -f /etc/os-release ]]; then
     export  RPMNAME="${SOFTWARE}-${OSREL_ID}-${OSREL_VERSION_ID}-${MACHINE}.rpm"
     export SPECNAME="${SOFTWARE}-${OSREL_ID}-${OSREL_VERSION_ID}-${MACHINE}.spec"
     export TARNAME="${SOFTWARE}-${OSREL_ID}-${OSREL_VERSION_ID}-${MACHINE}.tar"
  fi

  RPMPATH="$XTLD/pkg/build/$RPMNAME"
  RPMORIGINAL="$XTLD/pkg/build/tmp/rpmbuild/RPMS/${MACHINE}/$RPMNAME"
  echo "  + $RPMNAME" 1>&2

  export OVERSION="$VERSION"
  export VERSION="$(  echo $VERSION | sed -e 's/-/_/g' )"

  SPECPATH="$XTLD/pkg/build/tmp/rpmbuild/SPECS/${SPECNAME}"
  TARTARGET="${XTLD}/pkg/build/tmp/rpmbuild/SOURCES/${TARNAME}"

  cd "${XTLD}/pkg/build/tmp"

  mkdir -pm755 rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}

  (cd "${XTLD}/pkg/build/tmp/${COMPANY}"
       # wants  LisaEm-1.2.7_PRE_RC4_UNSTABLE_2021.10.11
       TARROOT="${SOFTWARE}"
       mv "${SOFTWARE}" "${TARROOT}"
       tar cpJf "${TARTARGET}.xz" "${TARROOT}"
       mv "${TARROOT}" "${SOFTWARE}"
  )

  makerpmspec "${SPECPATH}" "${TARNAME}.xz"

  if [[ "$( id -u)" == "0" ]]; then
     echo "Cannot run rpmbuild as user root, please run as a regular user, without sudo or su" 1>&2
  else
     cd "${XTLD}/pkg/build/tmp/rpmbuild"
     ( rpmbuild --define "_topdir ${XTLD}/pkg/build/tmp/rpmbuild" -bb "SPECS/${SPECNAME}" --target $MACHINE 2>&1 ) >"${XTLD}/pkg/build/tmp/rpmbuild.txt"
     mv "${XTLD}/pkg/build/tmp/rpmbuild/RPMS/${MACHINE}/"*.rpm "${XTLD}/pkg/${RPMNAME}"
  fi

  export VERSION="$OVERSION"
  # cleanup
  rm -rf "${XTLD}/pkg/tmp/rpmbuild"
  popd >/dev/null 2>/dev/null
}

# Creates a "pkg/LisaEm_Linux_x86_64.AppImage" standalone executable file that can be run on any Linux OS of the same architecture (e.g. x86_64, arm64).
# It requires the 'appimagetool' to be manually downloaded into subfolder 'scripts', e.g. for x86_64 Linux OS:
# sudo apt install libfuse2
# cd scripts
# wget https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage
# mv appimagetool-x86_64.AppImage appimagetool
# chmod +x appimagetool
#
function LinuxAppImage() {
  [[ ! -f "${XTLD}/scripts/appimagetool" ]] && { echo "The 'appimagetool' tool was not found in folder ${XTLD}/scripts . Will not create an '.AppImage' file. To fix this, please download the appropriate file for the $MACHINE platform from https://github.com/AppImage/appimagetool/releases/ , rename it to 'appimagetool', make it executable, and rerun."; return 0; }
  [[ ! -x "${XTLD}/scripts/appimagetool" ]] && { echo "The 'appimagetool' tool was found in folder ${XTLD}/scripts, but is not executable. Will not create an '.AppImage' file. To fix this, please run 'chmod +x appimagetool', then rerun."; return 0; }
  echo "  + AppImage ${SOFTWARE}" 1>&2

  pushd . >/dev/null 2>/dev/null

  APPDIR="${XTLD}/pkg/build/tmp/${SOFTWARE}.AppDir"
  APPIMAGE_NAME="${SOFTWARE}_Linux_${MACHINE}.AppImage"

  # Clean up
  rm -f ${XTLD}/pkg/*.AppImage
  rm -rf "${APPDIR}"
  mkdir -p "${APPDIR}"

  if [[ ! -d "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/" ]]; then
     echo "Folder ${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/ is missing" 1>&2
     exit 1
  fi

  # Copy contents from folder ${XTLD}/pkg/build/tmp/Sunder.NET/LisaEm into folder ${XTLD}/pkg/build/tmp/${SOFTWARE}.AppDir
  (cd "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}/" && tar cpf - .) | (cd "${APPDIR}" && tar xpf -)

  cd "${APPDIR}" || exit 1

  # Create the desktop file
  cat > "${SOFTWARE}.desktop" <<EOF
[Desktop Entry]
Name=${SOFTWARE}
Exec=lisaem
Icon=lisaem
Type=Application
Categories=System;Emulator;
Comment=${DESCRIPTION}
EOF
  # This is the icon of the AppImage
  cp -f ${XTLD}/resources/lisaem.png lisaem.png

  # Create file AppRun
  # When the ".AppImage" is executed, the Linux OS will extract it and "mount it" into a subfolder, e.g. "/tmp/.mount_LisaEmpomfmN", then the file AppRun will be run, which runs the "lisaem" executable (in subfolder usr/local/bin)
  cat > AppRun <<EOF
#!/bin/sh
SELF=\$(readlink -f "\$0")
# echo "SELF=\${SELF}" 1>&2
HERE=\${SELF%/*}
# echo "HERE=\${HERE}" 1>&2
# We shouldn't need anything in our PATH (or in any other env. variable) in order to run the lisaem binary
# However, we need the PATH below to be able to successfully open URLs (e.g. the ones in the "Help" menu) in a web browser.
PATH=/usr/local/bin:/usr/bin
# The lisaem binary is (should be) in subfolder usr/local/bin (along with the lisaem CLI tools)
exec "\${HERE}/usr/local/bin/lisaem" "\$@"
EOF
  chmod +x AppRun

  # echo "Running appimagetool from within folder $(pwd) ..." 1>&2
  # Generate the .AppImage file, e.g. a file named pkg/LisaEm_Linux_x86_64.AppImage
  ARCH="$MACHINE" ${XTLD}/scripts/appimagetool "${APPDIR}" "${XTLD}/pkg/${APPIMAGE_NAME}" >"${XTLD}/pkg/${APPIMAGE_NAME}.log" 2>&1

  # Cleanup
  cd ..
  rm -rf "${APPDIR}"

  popd >/dev/null 2>/dev/null
}


# Failed to load plugin: properties failed to load for lisaem: Additional properties are not allowed ('prepare', 'snap' were unexpected)
function makeSnapCraftYAMLandTar() {

targetlocal="$1"

BASE="core$(echo $OSREL_VERSION_ID | cut -f1 -d'.')"
[[ -z "$BASE" ]] && BASE="core20"

cat <<ENDOFSNAPCRAFTYAML >snapcraft.yaml
name: ${LCNAME} # you probably want to 'snapcraft register <name>'
base: $BASE
version: ${VER}
summary: ${DESCRIPTION}
description: ${DESCRIPTION}
grade: stable
confinement: ${SNAPCONFINEMENT}
compression: lzo
plugs:
  homedir:
    interface: personal-files
    write:
    - \$HOME/
apps:
  ${LCNAME}:
    command: ${SNAPCOMMAND}
    plugs: [ ${SNAPPLUGS} ]
parts:
  ${LCNAME}:
    stage-packages: [ ${SNAPDEPENDS} ]
    plugin: dump
    source-type: local
    source: snap
    organize:
      local: /
ENDOFSNAPCRAFTYAML

# create the tar file and add the file list from our package to the snapcraft.yaml file
(  cd "${XTLD}/pkg/build/tmp/${COMPANY}/${SOFTWARE}"
   tar cpf - . | (cd "$targetlocal" && tar xpf - ) 
   # tar cpJf "${tarname}" . 1>&2                                 # 123456789.......
   # find . -type f -print  | cut -c3- | while read line; do echo "      - ${line}"; done

   if [[ -d "${XTLD}/pkg/templates/snap" ]]; then
      (cd "${XTLD}/pkg/templates/snap"; tar cpf - . ) | ( cd "$SNAPHOME"; tar xpf - )
   fi
) # >>snapcraft.yaml

}

function LinuxSnapPackage() {
  # if we don't have snapcraft installed, ignore this package method, others will still be built
  [[ -z "$( which snapcraft 2>/dev/null )" ]] && return 0
  [[ -z "$( which multipass 2>/dev/null )" ]] && return 0

  [[ "$OSREL_ID" != "ubuntu" ]] && return 0 # only support snap building on ubuntu right now, might work on debian, and OS year must match core, i.e. 20.04=core20

  echo "  + Snapcraft ${SOFTWARE}" 1>&2

  mkdir -pm755 "${TLD}/pkg/build/tmp"
  pushd "${TLD}/pkg/build/tmp" 2>/dev/null >/dev/null

  # snaps need to be off /home/$USERNAME because multipass VM cannot mount
  # except from a limited set of directories.
  SNAPHOME="$HOME/snap-${COMPANY}-${SOFTWARE}/snap"
  SNAPPARENT="$HOME/snap-${COMPANY}-${SOFTWARE}"

  export TARGETLOCAL="${SNAPHOME}"

  mkdir -pm755 "${SNAPHOME}/local"
  cd           "${SNAPHOME}"

  makeSnapCraftYAMLandTar "${TARGETLOCAL}/local"

  cd "${SNAPPARENT}"
  snapcraft clean >/dev/null 2>/dev/null
  if snapcraft 2>&1 >snapcraft-build.log; then
     mv "$HOME/snap-${COMPANY}-${SOFTWARE}/${LCNAME}"*.snap "${XTLD}/pkg/" 2>/dev/null >/dev/null
     snapcraft clean >/dev/null 2>/dev/null
     rm -rf "$HOME/snap-${COMPANY}-${SOFTWARE}"
  else
     snapcraft --debug
  fi

  popd >/dev/null 2>/dev/null
}



##############################################################################
# getcpus
#
# Gets the number of CPUs available on the machine so we can issue multiple
# compiles simultaneously
#
##############################################################################

function getcpus()
{
  if [[ -z "$NUMCPUS" ]]; then
     export NUMCPUS="$( nproc )"
  fi
}


##############################################################################
# makelibs
#
# Creates both static and shared libraries.
#
# Parameters $1 target directory
#	     $2 library name
#            $3 version tripplet.  i.e. 0.3.6
#            $4 mode "static", "shared", or "both"
#            $5 is a single string containing objects to merge.
#               i.e. "a.o b.o c.o ..."
#
# i.e.
#            makelibs  . libGenerator 0.3.6 both "lib68k.o cpu68k-?.o"
#
##############################################################################
function makelibs() {

dir="$1"
libname="$2"
ver="$3"
mode="$4"
objs="$5"

aname="${libname}.${ver}.a"
laname="${libname}.a"
daname="${dir}/${aname}"
ldaname="${dir}/${laname}"

soname="${dir}/${libname}.${ver}.so"
lsoname="${dir}/${libname}.so"
ldsoname="${dir}/${libname}.so"
dsoname="${soname}"
dylibname="${dir}/${libname}.${ver}.dylib"
ldylibname="${dir}/${libname}.dylib"
dllname="${dir}/${libname}.${ver}.dll"
ldllname="${dir}/${libname}.dll"

[[ "$4" == "both" ]] && mode="static"


if [[ "$mode" == "static" ]]; then
     echo "  Creating  $libname.a" 1>&2
     $AR "$AROPTS" "${daname}" ${objs} || exit 1
     ranlib ${daname}         || exit 1
     /bin/rm -f       ${ldaname}
     ln -sf ${daname} ${ldaname}
fi

[[ "$4" == "both" ]] && mode="shared"

if [[ "$mode" == "shared" ]]; then
             echo "  Creating  $libname.so" 1>&2
             gcc -shared $ARCH -Wl,-soname,${soname} -o ${dsoname} ${objs} || exit 1
             /bin/rm -f          ${ldsoname}
             ln -sf ${dsoname}   ${ldsoname}
             ln -sf ${dsoname}   ${ldsoname}
fi

echo -n "" >/dev/null
}